import tkinter as tk
from tkinter import messagebox
from tkinter.filedialog import askopenfilename
import pandas as pd
import tensorflow as tf
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import roc_curve, auc, precision_recall_curve
from sklearn.model_selection import train_test_split

root = tk.Tk()
root.title('Machine Learning Analysis GUI')
root.geometry('800x450')
root.configure(background='white')

# Create a background image
background_image = tk.PhotoImage(file #here you need to copy paste the path of the picture that you have downloaded in your local machine)
background_label = tk.Label(root, image=background_image)
background_label.place(x=0, y=0, relwidth=1, relheight=1)

def run_ml_model():
    # ... Rest of the ML code ...
    model = pd.read_csv("Obfuscated-MalMem2022.csv")
    model.columns
    model['Class'] = model.Class.map({'Benign': 0, 'Malware': 1})

    X = model.drop(['Category'], axis=1)
    Y = model["Class"]

    # Shuffle data
    model = model.sample(frac=1).reset_index(drop=True)

    # Create training and test sets
    X_train, X_test, y_train = train_test_split(X, Y, test_size=0.2, random_state=42)

    # Set the random seed for reproducibility
    tf.random.set_seed(42)

    model = tf.keras.Sequential([
        tf.keras.layers.Dense(50, activation="relu"),
        tf.keras.layers.Dense(50, activation="relu"),
        tf.keras.layers.Dense(50, activation="relu"),
        tf.keras.layers.Dense(1, activation="sigmoid")
    ])

    model.compile(
        loss='binary_crossentropy',
        optimizer='adam',
        metrics=["accuracy"]
    )

    history = model.fit(X_train, y_train, epochs=5)

    model_1 = model.evaluate(X_test, y_test)
    model_1


# Make predictions with the TensorFlow model
    y_preds_new = model.predict(X_test)

# Plot the predictions
    def plot_predictions(predictions):
      plt.scatter(X_test, predictions, color='red', label='Predictions')
      plt.scatter(X_test, y_test, color='green', label='True values')
      plt.xlabel('X')
      plt.ylabel('Y')
      plt.legend()
      plt.show()

      plot_predictions(predictions=y_preds_new)

    # Plot loss curve
    plt.plot(history.history['loss'])
    plt.xlabel('Epochs')
    plt.ylabel('Loss')
    plt.title('Training Loss')
    plt.show()

    # Plot accuracy curve
    plt.plot(history.history['accuracy'])
    plt.xlabel('Epochs')
    plt.ylabel('Accuracy')
    plt.title('Training Accuracy')
    plt.show()

    # Obtain predicted probabilities for the test data
    predicted_probabilities = model.predict(X_test)

    # Convert predicted probabilities to class labels using a threshold
    threshold = 0.5  # Adjust the threshold based on your specific problem
    predicted_labels = tf.where(predicted_probabilities > threshold, 1, 0)

    # Calculate the confusion matrix
    cm = tf.math.confusion_matrix(y_test, predicted_labels)

    # Define class labels
    class_labels = ['Benign', 'Malware']

    # Plot confusion matrix
    plt.figure(figsize=(8, 6))
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', cbar=False)
    plt.title('Confusion Matrix')
    plt.xlabel('Predicted Label')
    plt.ylabel('True Label')
    plt.xticks(ticks=[0.5, 1.5], labels=class_labels)
    plt.yticks(ticks=[0.5, 1.5], labels=class_labels)
    plt.show()

    # Compute false positive rate (FPR), true positive rate (TPR), and thresholds
    fpr, tpr, thresholds = roc_curve(y_test, predicted_probabilities)

    # Compute Area Under the Curve (AUC)
    roc_auc = auc(fpr, tpr)

    # Plot ROC curve
    plt.figure(figsize=(8, 6))
    plt.plot(fpr, tpr, label='ROC Curve (AUC = %0.2f)' % roc_auc)
    plt.plot([0, 1], [0, 1], 'k--')  # Diagonal line indicating random guessing
    plt.xlim([0.0, 1.0])
    plt.ylim([0.0, 1.05])
    plt.xlabel('False Positive Rate (FPR)')
    plt.ylabel('True Positive Rate (TPR)')
    plt.title('Receiver Operating Characteristic (ROC) Curve')
    plt.legend(loc="lower right")
    plt.show()

    # Calculate precision and recall
    precision, recall, thresholds = precision_recall_curve(y_test, predicted_probabilities)

    # Plot precision-recall curve
    plt.figure(figsize=(8, 6))
    plt.plot(recall, precision)
    plt.xlabel('Recall')
    plt.ylabel('Precision')
    plt.title('Precision-Recall Curve')
    plt.grid(True)
    plt.show()

    # Calculate class distribution
    class_counts = [len(y_train[y_train == 0]), len(y_train[y_train == 1])]

    # Plot class distribution bar chart
    plt.figure(figsize=(8, 6))
    plt.bar(['Class 0', 'Class 1'], class_counts)
    plt.xlabel('Class')
    plt.ylabel('Count')
    plt.title('Class Distribution')
    plt.show()

    messagebox.showinfo("DL Analysis", "Deep Learning analysis completed.")
def run_ml_analysis():
    try:
        run_ml_model()
    except Exception as e:
        messagebox.showerror("Error", f"An error occurred: {str(e)}")

# Create a label
label_title = tk.Label(root, text="DEEP LEARNING ANALYSIS", font=("Arial", 24, "bold"), background='white')
label_title.place(x=180, y=70)

# Create label at the bottom
label_statement = tk.Label(root, text="Performing analysis using TensorFlow and pandas", font=("Arial", 14), background='white')
label_statement.place(x=250, y=400)

# Create a button to start ML analysis
button_start = tk.Button(root, text='Start Malware Analysis', command=run_ml_analysis, background='lightblue')
button_start.place(x=400, y=400, anchor='s', width=200)

root.mainloop()
